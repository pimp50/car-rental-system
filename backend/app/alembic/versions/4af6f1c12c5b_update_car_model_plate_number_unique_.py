"""Update Car model: plate_number unique and add car_id

Revision ID: 4af6f1c12c5b
Revises: c12e48605b0a
Create Date: 2026-01-13 19:28:50.657827

"""
from alembic import op
import sqlalchemy as sa
import sqlmodel.sql.sqltypes


# revision identifiers, used by Alembic.
revision = '4af6f1c12c5b'
down_revision = 'c12e48605b0a'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    
    bind = op.get_bind()
    import uuid
    
    # 1. Update existing NULL plate_numbers to a unique value to avoid constraint failure
    cars = bind.execute(sa.text("SELECT id, plate_number FROM car")).fetchall()
    for car in cars:
        if not car.plate_number:
            dummy_plate = f"TEMP-{str(uuid.uuid4())[:8]}"
            bind.execute(sa.text("UPDATE car SET plate_number = :plate WHERE id = :id"), {"plate": dummy_plate, "id": car.id})
    
    # 2. Check for duplicate plate_numbers and resolve them
    # Find duplicates
    duplicates = bind.execute(sa.text("""
        SELECT plate_number, COUNT(*) 
        FROM car 
        GROUP BY plate_number 
        HAVING COUNT(*) > 1
    """)).fetchall()
    
    for dup in duplicates:
        plate = dup.plate_number
        # Get all cars with this duplicate plate
        dup_cars = bind.execute(sa.text("SELECT id FROM car WHERE plate_number = :plate"), {"plate": plate}).fetchall()
        # Skip the first one, update the rest
        for i, car in enumerate(dup_cars[1:], 1):
             new_plate = f"{plate}-{i}"
             # Ensure length fits (max 16)
             if len(new_plate) > 16:
                 new_plate = f"D-{str(uuid.uuid4())[:13]}"
             bind.execute(sa.text("UPDATE car SET plate_number = :plate WHERE id = :id"), {"plate": new_plate, "id": car.id})

    
    # 3. Add car_id and set plate_number not null and unique
    with op.batch_alter_table('car', schema=None) as batch_op:
        batch_op.add_column(sa.Column('car_id', sa.Integer(), nullable=True)) 
        batch_op.create_unique_constraint('uq_car_car_id', ['car_id'])
        batch_op.alter_column('plate_number',
               existing_type=sa.VARCHAR(length=16),
               nullable=False)
        batch_op.create_index(batch_op.f('ix_car_plate_number'), ['plate_number'], unique=True)
    
    # 4. Populate car_id (simulating autoincrement for existing rows)
    cars = bind.execute(sa.text("SELECT id FROM car")).fetchall()
    for i, car in enumerate(cars, 1):
        bind.execute(sa.text("UPDATE car SET car_id = :cid WHERE id = :id"), {"cid": i, "id": car.id})
    
    # 4. (Optional) If we could, we would set car_id to NOT NULL here, but we added it as nullable=True above.
    #    Strictly speaking, it should be NOT NULL.
    #    SQLite batch alter allows altering column nullability.
    # with op.batch_alter_table('car', schema=None) as batch_op:
    #    batch_op.alter_column('car_id', nullable=False)


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('car', schema=None) as batch_op:
        batch_op.drop_constraint('uq_car_car_id', type_='unique')
        batch_op.drop_index(batch_op.f('ix_car_plate_number'))
        batch_op.alter_column('plate_number',
               existing_type=sa.VARCHAR(length=16),
               nullable=True)
        batch_op.drop_column('car_id')
    # ### end Alembic commands ###
